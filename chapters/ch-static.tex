\newpage
\chapter{Statische Algorithmen }
\workTodo{Labels für die einzelnen Texte umbenennen}
Es ist mit dieser Art von Algorithmen möglich Ausreißer in einer vollständigen und abgeschlossenen Zeitreihe zu identifizieren. Es werden zwei Algorithmen vorgestellt, ein auf Percolation basierender Algorithmus und ein auf IsoMap basierender Algorithmus. Beide Algorithmen wurden dazu entwickelt Ausreißer in unterschiedlichen Typen von Datensätzen zu erkennen (z.B. Videos, Bilder, Netzwerke). Voraussetzung hierfür ist lediglich, dass eine Distanz zwischen unterschiedlichen Elementen des Datensatzes berechnet werden kann  \citep[vgl.][S.~2]{10.3389/fphy.2019.00194}. Im Folgenden werden die Algorithmen, hinsichtlich ihrer Fähigkeit Ausreißer in Zeitreihen zu identifizieren evaluiert.

Für beide Algorithmen gilt, dass die Zeitreihe zunächst in ein Netzwerk umgewandelt werden muss. Hierzu wird ebenfalls Formel 1 verwendet. Beide Algorithmen liefern lediglich einen Ausreißer Score zurück. Um zu bestimmen inwiefern ein Element konkret ein Ausreißer ist, wird zunächst den Mittelwert und die Standardabweichung des Outlier Scores berechnet. Falls ein Element in Abhängigkeit von der Standardabweichung sehr stark vom Mittelwert abweicht wird das Element als Ausreißer klassifiziert.
\section{IsoMap Basierter Algorithmus}
\label{chap:rw}
Der Grundgedanke hinter diesem Ansatz ist, dass Informationen über Ausreißer bei der Reduzierung der Dimensionalität mit dem IsoMap Algorithmus verloren gehen. Insofern versucht wird, die Informationen zu rekonstruieren und mit der ursprünglichen Matrix vergleicht, können große Abweichungen bei Ausreißer Elementen festgestellt werden \citep[vgl.][S.~3]{10.3389/fphy.2019.00194}. 


\subsection{IsoMap}
\label{sec:rw-gl}
Beim IsoMap handelt es sich um einen Algorithmus zur nichtlinearen Dimensionsreduktion. Zunächst werden beim IsoMap die Nachbarn eines jeden Punktes über K-Nearest Neighbor bestimmt. Anschließend wird jeder Punkt mit den gefundenen Nachbarn verknüpft, wodurch ein neuer Körper entsteht. Daraufhin wird eine neue Distanzmatrix auf dem entstandenen Körper berechnet. Diese Matrix kann auch als geodätische Distanzmatrix bezeichnet werden und wird im weiteren Verlauf des Algorithmus benötigt. Der Zweck des Ablaufs ist es das nichtlineare Zusammenhänge in der anschließenden Dimensionsreduktion erhalten bleiben. Die Dimensionsreduktion erfolgt anschließend über Eigenvektor ? \citep[vgl.][S.~3]{Tenenbaum2319}.
\workTodo{Noch nach Seite für Quelle suchen}

\begin{figure}[H]
	\centering
	\includegraphics[width=5cm]{fig/isomap_circle.png}
	\caption{Funktionsweiße IsoMap}
	\label{img:isomap}
\end{figure}


\subsection{IsoMap Basierter Algorithmus}
\label{sec:rw-gl-cd}
Mithilfe des IsoMap Algorithmus wurden neue Features berechnet. Im nächsten Schritt wird versucht aus diesen Features die ursprüngliche Distanzmatrix zu rekonstruieren. Nun kann die Distanzmatrix aus \autoref{sec:rw-gl} mit dieser Distanzmatrix verglichen werden. Dazu wird die Pearson Korrelation zwischen den jeweiligen Vektoren der Matrizen berechnet. Für Ausreißer wird erwartet, dass die Ähnlichkeit sehr niedrig ist, da die Informationen über sie bei der Reduktion verloren gehen \citep[vgl.][S.~3]{10.3389/fphy.2019.00194}.

\subsection{Implementierung}
\label{sec:im-implement}
Da für die Implementierung des Algorithmus viele Berechnungen mit Matrizen durchgeführt werden müssen, wurde hierzu auf Python/Numpy zurückgegriffen. Für den IsoMap Algorithmus existierte eine sehr gute Implementierung in SciKitLearn, deshalb wurde auf diese zurückgegriffen. An den Algorithmus können verschieden Parameter übergeben werden, es handelt sich hierbei um dieselben Parameter, welche auch an den IsoMap Algorithmus übergeben werden können.

\subsection{Ergebnisse}
\label{sec:im-results}
\begin{table}
\caption{IsoMap Performance}
\begin{tabular}{ |p{4.5cm}||p{4.5cm}||p{3cm}|}
	\hline
	\textbf{Ausreißer Typ}& \textbf{Datei Name}&
	\textbf{1D}\\
	\hline
	\hline
	Einzelne Peaks & anomaly-art-daily-peaks & *\\
	\hline
	Zunahme an Rauschen & anomaly-art-daily-increase-noise &**\\
	\hline
	Signal Drift & anomaly-art-daily-drift &**\\
	\hline
	Kontinuierliche Zunahme der Amplitude& art-daily-amp-rise & **\\
	\hline
	Zyklus mit höherer Amplitude & art-daily-jumpsup &*\\
	\hline
	Zyklus mit geringerer Amplitude & art-daily-jumpsdown & **\\
	\hline
	Zyklus-Aussetzer & art-daily-flatmiddle &*\\
	\hline
	Signal-Aussetzer & art-daily-nojump & -\\
	\hline
	Frequenzänderung & anomaly-art-daily-sequence-change &-\\
	\hline
\end{tabular}
\end{table}

Der IsoMap Algorithmus liefert eher schwache Ergebnisse bei der Erkennung von Ausreißern in Zeitreihen. Hauptproblem hierbei ist, dass starke Anstiege in der Zeitreihe zu starken Ausschlägen im Ausreißer Score führt. An den Stellen, an welchen sich tatsächlich Ausreißer befinden, kommt es je nach Ausreißer Typ ebenfalls zu Ausschlägen im Ausreißer Score. Jedoch sind diese Ausschläge etwa so groß wie die der Übergänge. Deshalb ist es nur schwer möglich die Ausreißer zu identifizieren. Das selbe Problem trat auch in \citep {Uzun} bei der Ausreißer Erkennung mit dem Random Walk Algorithmus auf. Um das Problem zu lösen wurde hierbei eine Glättung der Zeitreihe durchgeführt. Dadurch sind die Übergänge zwischen den Abschnitten nicht mehr so plötzlich und werden nicht mehr als Ausreißer markiert \citep[vgl.][S.~31,36]{Uzun}. Um Zukünftig bessere Ergebnisse zu erzielen, wäre das ein möglicher Ansatz.\\
Des Weiteren ist zu erkennen, dass der Algorithmus für einige Ausreißer Typen nicht geeignet ist. Hierzu gehören die Ausreißer Typen, welche sich nicht vom Wertebereich her ändern.  

\workTodo{Wie genau bezieht man sich auf seine eigene Ausarbeitung} 

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{fig/resultsIsoMap/problem_transitions.PNG}
	\caption{Problem Übergänge}
	\label{img:perc_proc}
\end{figure}


\newpage
\section{Perculation}
\label{sec:per-intro}
Bei diesem Algorithmus werden schrittweiße die Kanten mit den höchsten Gewichten aus der Distanzmatrix entfernt. Ziel dieses Prozesses ist es Ausreißer vom Hauptcluster zu trennen. Dabei kann davon ausgegangen werden, dass Ausreißer höhere Kantengewichte zu ihren Nachbarn aufweisen und deshalb schneller separiert werden. Sobald ein Knoten komplett separiert ist, wird ihm ein Ausreißer Score zugeordnet. Der Wert des Ausreißer Scores wird über die zuletzt entfernte Kante des Knoten definiert \citep[vgl.][S.~3]{10.3389/fphy.2019.00194}. 

\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{fig/perco_procedure.png}
	\caption{Ablauf Perculation basierter Algorithmus}
	\label{img:perc_proc}
\end{figure}

\subsection{Implementierung}
\label{sec:per-imp}
Aus denselben Gründen wie in \autoref{sec:im-implement} erläutert, wurde für die Implementierung auf Python/Numpy zurückgegriffen.  Da die Distanzmatrix sehr umfangreich werden kann wurden einige Veränderungen an dem Algorithmus vorgenommen, um ihn Performanter zu machen. Eine Modifikation, die vorgenommen wurde, ist das die Kanten nicht einzeln, sondern in Gruppen entfernt werden. Dadurch muss seltener überprüft werden, ob ein Knoten mittlerweile komplett isoliert ist. Außerdem wurde ein Abbruchkriterium implementiert, bei welchem der Algorithmus angehalten wird sobald eine bestimmte Prozentzahl an Kanten entfernt wurde. Dies hat keine Auswirkungen auf die Qualität der Ausreißer Erkennung, da Ausreiser üblicherweise bereits zu beginn des Algorithmus isoliert werden. Der Algorithmus berechnet für jedes Element der Zeitreihe einen Ausreißer Score. Allerdings können die Ausreißer Scores sehr stark schwanken. Deshalb ist es schwierig Ausreißer zu identifizieren, welche sich über mehrere Zeitschritte erstrecken, da kein kontinuierliches Ansteigen des Scores beobachtet werden kann. Eine Möglichkeit, um diese Art der Ausreißer trotzdem zu identifizieren, ist es ein Sliding Window Verfahren einzusetzen. Dabei wird der Ausreißer Score für jedes Element neu berechnet, indem ein Mittelwert über die Zeitpunkte vor einem und nach einem Element gebildet wird. Dadurch werden die Schwankungen im Ausreißer Score abgemildert. Prinzipiell ist der Algorithmus parameterfrei, durch die Veränderungen kann jedoch die Größe des Sliding Window als Parameter übergeben werden.

\begin{figure}[h]
	\centering
	\subfloat{
		\includegraphics[width=0.5\textwidth]{fig/resultsPercolation/art_daily_jumpsup}}
	\subfloat{
		\includegraphics[width=0.5\textwidth]{fig/resultsPercolation/art_daily_jumpsup_ohne}}
	\caption{Vergelich Perculation Algorithmus mit Sliding Window Verfahren und ohne Sliding Window Verfahren}
	\label{img:vardir1}
\end{figure}

\subsection{Ergebnisse}
\label{sec:per-result}

\begin{table}
\caption{Perculation Time Series Performance}
\begin{tabular}{ |p{6cm}||p{6cm}||p{3cm}|}
	\hline
	\textbf{Ausreißer Typ}& \textbf{Datei Name}&
	\textbf{1D}\\
	\hline
	\hline
	Einzelne Peaks & anomaly-art-daily-peaks & *\\
	\hline
	Zunahme an Rauschen & anomaly-art-daily-increase-noise &****\\
	\hline
	Signal Drift & anomaly-art-daily-drift &***\\
	\hline
	Kontinuierliche Zunahme der Amplitude& art-daily-amp-rise & ***\\
	\hline
	Zyklus mit höherer Amplitude & art-daily-jumpsup &****\\
	\hline
	Zyklus mit geringerer Amplitude & art-daily-jumpsdown & ****\\
	\hline
	Zyklus-Aussetzer & art-daily-flatmiddle &****\\
	\hline
	Signal-Aussetzer & art-daily-nojump & -\\
	\hline
	Frequenzänderung & anomaly-art-daily-sequence-change &-\\
	\hline
\end{tabular}
\end{table}

\label{sec:per-results-text}
Die Qualität der Ausreißer Erkennung mit dem Perculation Algorithmus kann großenteils als gut bis sehr gut bezeichnet werden. Lediglich die Ausreißer Typen Einzelne Peaks, Signal Aussetzer und Frequenzänderung können vom Algorithmus nicht erkannt werden. Bei den einzelnen Peaks liegt das an der Verwendung des Sliding Window Verfahren, dadurch werden die Ausschläge im Ausreißer Score weggemittelt und können nur noch sehr schlecht identifiziert werden. Wird jedoch kein Sliding Window Verfahren angewandt können die Ausreißer sehr gut identifiziert werden. Signal Aussetzer und Frequenzänderungen können vom Perculation Algorithmus nicht identifiziert werden, weil die Werte der Zeitreihe hierbei nicht von den Werten der restlichen Zeitreihe abweichen.   



\workTodo{Die richtigen Ergebnisse rein machen und bisschen was drüber schreiben}

\workTodo{Die Bilder vielleicht noch überarbeiten, sodass sie schöner aussehen. Vielleicht auch noch die Tabelle mit den Sternen rein machen. Vielleicht die beiden Graphiken zu einer Zusammenführen.}

\workTodo{Fragestellung: Inwieweit können vielleicht auch andere Datensätze in Graphen umgewandelt werden, sodass z.B. der Netismile darauf angewendet werden kann. }