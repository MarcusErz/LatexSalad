\newpage
\chapter{Statische Algorithmen zur Ausreißer Erkennung}
In diesem Kapitel werden zunächst zwei statische Algorithmen zur Ausreißer-Erkennung auf unterschiedlichen Datentypen (z.B. Videos, Bilder, Netzwerke) vorgestellt. Hierbei handelt es sich um ein auf Percolation basierender Algorithmus und ein auf IsoMap basierender Algorithmus. Statische Algorithmen kennzeichnet, dass sie nicht mit Daten umgehen könne, welche kontinuierlich an sie übergeben werden. Damit die Algorithmen anwendbar sind, müssen die Daten vollständig und abgeschlossen vorliegen. Eines unserer Hauptziele des Forschungsprojektes war die Ausreißer Erkennung in Zeitreihen, aus diesem Grund haben wir uns in den Experimenten auf diese Art der Daten konzentriert. In \autoref{sec:IsoBased} wird der IsoMap basierte Algorithmus vorgestellt in \autoref{sec:per-intro} wird der Percolation basierte Algorithmus vorgestellt.

Beide Algorithmen liefern lediglich einen Ausreißer Score zurück. Um zu bestimmen inwiefern ein Element konkret ein Ausreißer ist, wird zunächst den Mittelwert und die Standardabweichung des Outlier Scores berechnet. Falls ein Element in Abhängigkeit von der Standardabweichung sehr stark vom Mittelwert abweicht wird das Element als Ausreißer klassifiziert.

\section{Umwandlung Zeitreihe in Netzwerk}

Damit sowohl der auf Perculation basierende Algorithmus wie auch der auf Iso Map basierende Algorithmus angewandt werden können, müssen die Daten zunächst in ein einheitliches Format überführt werden. Dazu müssen die unterschiedlichen Daten in ein Netzwerk umgewandelt werden.  Hierzu ist erforderlich, dass eine Distanz zwischen unterschiedlichen Elementen des Datensatzes berechnet werden kann  \citep[vgl.][S.~2]{10.3389/fphy.2019.00194}. Der Algorithmus kann auf allen Daten angewandt werden, welche diese Vorraussetzung erfüllen. Nachfolgend wird exemplarisch beschrieben wie die Transformation für eine Zeitreihe funktionieren kann. 


\label{sec:trsnsNeti}
Für die Transformation der Zeitreihe muss zunächst die Distanz zwischen den einzelnen Elementen (Zeitpunkten) der Zeitreihe berechnet werden. Hierzu wird das Distanzmaß aus  \autoref{eq:euklidianDist} genutzt. 

\begin{equation}
	D_{ij}=\left(\sum_{k} \left|v_{k}^{i}-v_{k}^{j}\right|^{p}\right)^{1/p} \label{eq:euklidianDist}
\end{equation}

Insofern in die Gleichung für p = 2 eingesetzt wird, handelt es sich hierbei um die euklidische Distanz. Die mit \autoref{eq:euklidianDist} berechneten Distanzen bilden die Kantengewichte in dem neu erstellten Netzwerk. Dabei handelt es sich um ein vollständiges Netzwerk. Das heißt, jeder Knoten ist mit allen anderen Knoten über eine Kante verknüpft. Die Knoten des Netzwerks repräsentieren die einzelnen Elemente(Zeitpunkte) der Zeitreihe. \citep[vgl.][S.~2]{10.3389/fphy.2019.00194}. Es können mit dieser Vorgehensweise auch multivariate Zeitreihen in ein Netzwerk transformiert werden.


\section{IsoMap Basierter Algorithmus}
\label{sec:IsoBased}
Der Ansatz dieses Algorithmus ist, dass Informationen über Ausreißer bei der Reduzierung der Dimensionalität mit dem IsoMap verloren gehen. Insofern versucht wird, die Informationen zu rekonstruieren und mit der ursprünglichen Matrix vergleicht, können große Abweichungen bei Ausreißer Elementen festgestellt werden \citep[vgl.][S.~3]{10.3389/fphy.2019.00194}. In \autoref{ssec:iso-algo} wird zunächst erklärt wie der IsoMap Algorithmus eine Reduzierung der Dimensionalität durchführt. Anschließend werden in \autoref{ssec:iso-weiter} die zusätzlichen Schritte erläutert, welche notwendig sind um Ausreißer mithilfe des IsoMap Algorithmus zu erkennen.


\subsection{IsoMap}
\label{ssec:iso-algo}
Beim IsoMap handelt es sich um einen Algorithmus zur nichtlinearen Dimensionsreduktion. Zunächst werden beim IsoMap Algorithmus die Nachbarn eines jeden Punktes(Knoten) über den Ball Tree Algorithmus oder den KD Tree Algorithmus bestimmt. Anschließend wird jeder Punkt mit den gefundenen Nachbarn verknüpft, wodurch ein neuer Körper(Netzwerk) entsteht. Daraufhin wird eine neue Distanzmatrix auf dem entstandenen Körper berechnet, indem die kürzeste Distanz zwischen allen Punkten auf dem Körper berechnet wird. Diese Matrix kann auch als geodätische Distanzmatrix $D_{G}$ bezeichnet werden. Die eigentliche Dimensionsreduktion wird anschließend über die Eigenvektoren und Eigenwerte der Matrix $D_{G}$ durchgeführt. Das Ergebnis der Dimensionsreduktion ist eine neue Menge an Features für jedes Element $V^{i} = {v^{i}_{1}. . . v^{i}_{r}}$ des ursprünglichen Datensatzes. Durch das Erzeugen der Matrix $D_{G}$ wird erreicht, das nichtlineare Zusammenhänge bei der Dimensionsreduktion erhalten bleiben. \citep[vgl.][S.~3-4]{Tenenbaum2319}.

\begin{figure}[H]
	\centering
	\includegraphics[width=5cm]{fig/isomap_circle.png}
	\caption{Berechnung der Distanz zwischen zwei Punkten nach Anwendung des IsoMap Algorithmus}
	\label{img:isomap}
\end{figure}


\subsection{IsoMap Algorithmus zur Erkennung von Ausreißern}
\label{ssec:iso-weiter}
Mithilfe des IsoMap Algorithmus wurden für jedes Element neue Features ($V^{i} = {v^{i}_{1}. . . v^{i}_{r}}$) berechnet. Im nächsten Schritt wird versucht aus diesen Eigenschaften die ursprüngliche Distanzmatrix zu rekonstruieren. Dazu wird aus den Eigenschaften $V^{i}$ unter Verwendung von \autoref{eq:euklidianDist} eine neue Distanzmatrix $\hat{D}$ berechnet. Nun können die Matrizen $D_{G}$ und $\hat{D}$ miteinander verglichen werden. Hierzu muss die Pearson Korrelation zwischen den jeweiligen Spalten der Matrizen berechnet werden. Für Ausreißer wird erwartet, dass die Korrelation sehr niedrig ist, da Informationen über sie bei der Reduktion verloren gehen \citep[vgl.][S.~3]{10.3389/fphy.2019.00194}. Die Korrelation kann also als Ausreißer Score genutzt werden. Um zu klassifizieren, ob es sich bei einem konkreten Element um einen Ausreißer handelt, wird zunächst der Mittelwert und die Standardabweichung des Ausreißer Score berechnet. Falls ein Element um einen bestimmten Threshold vom Mittelwert abweicht, wird das Element als Ausreißer klassifiziert.

\subsection{Implementierung}
\label{sec:im-implement}
Für den IsoMap Algorithmus stellt scikit-learn eine sehr gute Implementierung zur Verfügung \citep{sklearnIso}. Diese Implementierung konnten wir gut in unseren Algorithmus integrieren. Es musste lediglich geändert werden, dass auf die Matrix $D_{G}$ zugegriffen werden kann. Dies ist standardmäßig nicht der Fall. Für die Implementierung der weiteren Funktionalität wurde auf Python/NumPy zurückgegriffen. 

\subsection{Ausreißer-Erkennung in Zeitreihen}
\label{sec:im-results}

\begin{table}
	\centering
	\begin{tabular}{p{0.47\linewidth}|p{0.4\linewidth}|P{0.05\linewidth}}
		\toprule
		\textbf{Ausreißer Typ}& \textbf{Datei Name}&
		\textbf{1D}\\
		\midrule
	Einzelne Peaks (vgl. \autoref{img:dailyPeaksIso}) & anomaly-art-daily-peaks & *\\
		\midrule
	Zunahme an Rauschen (vgl. \autoref{img:increaseNoiseIso}) & anomaly-art-daily-increase-noise &**\\
		\midrule
	Signal Drift (vgl. \autoref{img:dailyDriftIso}) & anomaly-art-daily-drift &**\\
		\midrule
	Kontinuierliche Zunahme der Amplitude (vgl. \autoref{img:ampRiseIso})& art-daily-amp-rise & **\\
		\midrule
	Zyklus mit höherer Amplitude (vgl. \autoref{img:jumpsupIso})& art-daily-jumpsup &*\\
		\midrule
	Zyklus mit geringerer Amplitude (vgl. \autoref{img:jumpsdownIso})& art-daily-jumpsdown & **\\
		\midrule
	Zyklus-Aussetzer (vgl. \autoref{img:flatmiddleIso})& art-daily-flatmiddle &*\\
		\midrule
	Signal-Aussetzer (vgl. \autoref{img:nojumpIso})& art-daily-nojump & -\\
		\midrule
	Frequenzänderung (vgl. \autoref{img:sequenceChangeIso})& anomaly-art-daily-sequence-change &-\\
		\bottomrule
	\end{tabular}
	\caption{IsoMap Performance}
	\label{tab:isomap:performance}
\end{table}


Für die durchgeführten Tests wurden die Zeitreihen aus ... verwendet. Um zu bewerten wie gut der Algorithmus funktioniert, wurde ein Punktesystem eingeführt. In dem Punktesystem konnten maximal vier Sterne erreicht werden. Das bedeutet Ausreißer sehr gut erkannt. Null Sterne hingegen bedeuten Ausreißer überhaupt nicht erkannt. Der IsoMap Algorithmus liefert eher schwache Ergebnisse bei der Erkennung von Ausreißern in Zeitreihen. Hauptproblem hierbei ist, dass starke Anstiege, bei welchen es sich nicht um Ausreißer handelt, fälschlicherweise zu einem starken Anstieg des Ausreißer Scores führen (vgl. \autoref{img:iso_trans} mit Pfeil markierte stellen). Dies kann, je nach Threshold, zu einer hohen Quote an falsch positiven Klassifizierungen führen. Aus diesem Grund können die tatsächlichen Ausreißer nicht eindeutig identifiziert werden. Eine Ähnliche Problematik trat in \citep {Uzun} bei der Verwendung des Random Walk Algorithmus auf. Das Problem konnte hierbei gelöst werden, indem vor der Anwendung des Algorithmus, eine Glättung der Zeitreihe durchgeführt wurde. Dadurch werden abrupte Übergange in der Zeitreihe abgemildert und deshalb nicht mehr als Ausreißer erkannt \citep[vgl.][S.~31,36]{Uzun}. Dies könnte ein möglicher Ansatz sein um zukünftig bessere Ergebnisse zu erzielen.\\
Des Weiteren ist zu erkennen, dass der Algorithmus für einige Ausreißer Typen nicht geeignet ist, hierzu gehören Siganl Aussetzer und Frequenzänderungen. Bei diesen Ausreißer Typen treten keinerlei unüblichen Werte auf, sondern es kommt zu Änderungen in der Saisonalität der Zeitreihe. 

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{fig/resultsIsoMap/problem_transitions.PNG}
	\caption{Problem Übergänge}
	\label{img:iso_trans}
\end{figure}


\newpage
\section{Perculation basierter Algorithmus}
\label{sec:per-intro}
Bei diesem Algorithmus werden schrittweise die Kanten mit den höchsten Gewichten aus der mit \autoref{eq:euklidianDist} erzeugten Distanzmatrix $D_{ij}$ entfernt. Ziel dieses Prozesses ist es Ausreißer vom restlichen Teil des Netzwerks zu trennen. Dabei kann davon ausgegangen werden, dass Ausreißer höhere Kantengewichte zu ihren Nachbarn aufweisen und deshalb schneller separiert werden. Sobald ein Knoten komplett separiert ist, wird ihm ein Ausreißer Score zugeordnet. Der Wert des Ausreißer Scores wird über die zuletzt entfernte Kante des Knoten definiert. Dadurch erhalten früher separierte Knoten höhere Ausreißer Scores als später separierte Knoten \citep[vgl.][S.~3]{10.3389/fphy.2019.00194}. 

\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{fig/perco_procedure.png}
	\caption{Ablauf Perculation basierter Algorithmus}
	\label{img:perc_proc}
\end{figure}

\subsection{Implementierung}
\label{sec:per-imp}
Für die Implementierung des Perculation-basierten Algorithmus wurde genauso wie in \autoref{sec:im-implement}, Python/Numpy verwendet. Bei der Implementierung eines Prototypen des Algorithmus konnte festgestellt werden, das die Laufzeit des Algorithmus sehr langsam ist. Aus diesem Grund wurden einige Veränderungen an dem Algorithmus vorgenommen um die Performance zu verbessern. Dazu gehörte, dass nicht einzelne Kanten, sondern Gruppen an Kanten aus dem Netzwerk entfernt werden. Der Vorteil dieser Modifikation ist, dass seltener überprüft werden muss ob ein Knoten weiterhin mit den Rest des Netzwerks verbunden ist. Eine weitere Verbesserung, die eingeführt wurde, ist die Verankerung eines Abbruchkriteriums. Dabei wird der Algorithmus angehalten sobald 
eine bestimmte Menge an Kanten aus dem Netzwerk entfernt wurde. Da der Algorithmus nicht alle Berechnungen ausführen muss, kann damit eine Optimierung der Laufzeit erreicht werden. Weiterhin konnte festgestellt werden, dass diese Veränderung keinen Einfluss auf die Qualität der Ausreißer Erkennung hat, da Ausreißer lediglich zu Beginn des Algorithmus gefunden werden. Ein weiteres Problem des Ursprünglichen Algorithmus war, das bei aufeinanderfolgenden Elemente der Zeitreihe teilweiße starke Schwankungen im Ausreißer Score auftraten (vgl. \autoref{img:vardir1}). Aus diesem Grund konnten Ausreißer, welche sich über mehrere Zeitpunkte hinweg erstrecken nicht komplett erkannt werden. Um die Schwankungen im Ausreißer Score abzumildern, wurde dieser geglättet. Dazu wurde der Gleitende Mittelwert des Ausreißer Score berechnet. In \autoref{eq:slidingAverage} ist exemplarisch die Formel für einen Gleitenden Mittelwert der Ordnung drei dargestellt. In \autoref{img:vardir1} ist zu sehen wie sich der Ausreißer Score durch das Glätten verändert. 
\begin{equation}
	m_{\text{MA}}^{(3)}(t)={\frac {1}{3}}{\Big (}x(t-1)+x(t)+x(t+1){\Big )} \label{}
\end{equation} 

\workTodo{Das Verfahren zur Glättung das hier eingesetzt wird heißt gleitender Mittelwert. Vielleicht Formel davon einfügen und dan noch passende Quelle finden}
\workTodo{Parameter noch erklären} 
\begin{figure}[h]
	\centering
	\subfloat{
		\includegraphics[width=0.5\textwidth]{fig/resultsPercolation/art_daily_jumpsup}}
	\subfloat{
		\includegraphics[width=0.5\textwidth]{fig/resultsPercolation/art_daily_jumpsup_ohne}}
	\caption{Vergelich Perculation Algorithmus mit Sliding Window Verfahren und ohne Sliding Window Verfahren}
	\label{img:vardir1}
\end{figure}

Um zu klassifizieren, ob es sich bei einem konkreten Element um einen Ausreißer handelt, wird zunächst der Mittelwert und die Standardabweichung des Ausreißer Score berechnet. Falls ein Element um einen bestimmten Threshold vom Mittelwert abweicht, wird das Element als Ausreißer klassifiziert.

\subsection{Ausreißererkennung in Zeitreihen}
\label{sec:per-result}

\begin{table}
	\centering
	\begin{tabular}{p{0.47\linewidth}|p{0.4\linewidth}|P{0.05\linewidth}}
		\toprule
		\textbf{Ausreißer Typ}& \textbf{Datei Name}&
		\textbf{1D}\\
		\midrule
	Einzelne Peaks (vgl. \autoref{img:dailyPeaksPerc}) & anomaly-art-daily-peaks & *\\
		\midrule
	Zunahme an Rauschen (vgl. \autoref{img:increaseNoisePerc}) & anomaly-art-daily-increase-noise &****\\
		\midrule
	Signal Drift (vgl. \autoref{img:dailyDriftPerc}) & anomaly-art-daily-drift &***\\
		\midrule
	Kontinuierliche Zunahme der Amplitude (vgl. \autoref{img:ampRisePerc}) & art-daily-amp-rise & ***\\
		\midrule
	Zyklus mit höherer Amplitude (vgl. \autoref{img:jumpsupPerc}) & art-daily-jumpsup &****\\
		\midrule
	Zyklus mit geringerer Amplitude (vgl. \autoref{img:jumpsdownPerc}) & art-daily-jumpsdown & ****\\
		\midrule
	Zyklus-Aussetzer (vgl. \autoref{img:flatmiddlePerc}) & art-daily-flatmiddle  &****\\
		\midrule
	Signal-Aussetzer (vgl. \autoref{img:nojumpPerc}) & art-daily-nojump & -\\
		\midrule
	Frequenzänderung (vgl. \autoref{img:sequenceChangePerc}) & anomaly-art-daily-sequence-change &-\\
		\bottomrule
	\end{tabular}
	\caption{Perculation Time Series Performance}
	\label{tab:perculation:timeseriesperformance}
\end{table}

\label{sec:per-results-text}
Es konnte festgestellt werden, dass der Perculation basierte Algorithmus, viele Ausreißer Typen sehr gut erkennt. Ob Ausreißer in einer Zeitreihe mit einzelnen Peaks gefunden werden, hängt davon ab, ob der Ausreißer Score geglättet wird. Insofern keine Glättung des Ausreißer Scores durchgeführt wird, können einzelne Peaks gefunden werden. Denn durch die Glättung der Zeitreihe verschwinden die Ausschläge im Ausreißer Score. Es muss also in Abhängigkeit des Anwendungsfalles entschieden werden ob der Ausreißer Score geglättet wird. Dabei wäre ebenfalls denkbar, das beide Varianten zur Erkennung von Ausreißern verwendet werden. Der Perculation basierte Algorithmus ist genauso wie der Iso Map basierte Algorithmus (vgl. \autoref{sec:im-results}) nicht dazu im Stande Ausreißer in Zeitreihen mit Signal Aussetzer und Frequenzänderung zu erkennen.   
