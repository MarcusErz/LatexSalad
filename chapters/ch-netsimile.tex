\newpage
\chapter{Netsimile}
\label{chap:ns}
\workTodo{In diesem Kapitel werden grundlegende Themen behandelt, die im Rahmen des Forschungsprojekts zum Verständnis der Ausreißer-Erkennung in Graphen gedient haben.}

\section{Grundlagen}
\label{sec:ns-gl}

NetSimile ist ein skalierbarer Algorithmus zur Erkennung von Ähnlichkeiten, sowie Anomalien, in Netzwerken unterschiedlicher Größen. Wenn der Datensatz eines Graphs über die Zeit in bestimmte Abstände, wie z.B. in Tage, unterteilt wird, so kann NetSimile die Veränderung des Graphs über die Zeit bewerten. Der Algorithmus extrahiert strukturelle Merkmale aus den Momentaufnahmen des Graphs für jeden Tag. Diese Merkmale bilden den Signaturvektor für jeden Graphen in der sich verändernden Netzwerkumgebung und bestehen aus den Ego-Netzeigenschaften, Knotengrad, Clustering-Koeffizient usw. Um die Ähnlichkeit zwischen zwei Graphen bewerten zu können, wird beim NetSimile der Abstand ihrer entsprechenden Signaturvektoren berechnet. Dieser Abstand wird Canberra Distance genannt. \citep[vgl.][S.~1]{Netsimile}

Als Input für diesen Algorithmus wird eine Menge von $k$-anonymisierten Netzwerken mit beliebig unterschiedlichen Größen, die keine überlappenden Knoten oder Kanten besitzen sollten, herangezogen werden. Das Resultat sind Werte für die strukturelle Ähnlichkeit oder Abstands eines jeden Paares der gegebenen Netzwerke bzw. ein Merkmalsvektor für jedes Netzwerk. \citep[vgl.][S.~1]{Netsimile}

NetSimile durchläuft drei Schritte, die im Folgenden erläutert werden.

\subsubsection{Extrahierung von Merkmalen}
Für jeden Knoten $i$ werden, basierend auf ihren Ego-Netzwerken, die folgenden Merkmale generiert:


\begin{description}
	\item[$\overline{d}_i = |N(i)|$]\hfill\\ Die Anzahl der Nachbarn (d.h. Grad) von Knoten $i$, wobei $N(i)$ die Nachbarn von Knoten $i$ beschreibt.
	\item[$\overline{c}_i$]\hfill\\ Der Clustering-Koeffizient von Knoten $i$, der als die Anzahl von Dreiecken, die mit Knoten $i$ verbunden sind, über die Anzahl von verbundenen Dreiecken, die auf Knoten $i$ zentriert sind, definiert ist.
	\item[$d_{N(i)}$]\hfill\\ Die durchschnittliche Anzahl der Nachbarn von Knoten $i$, die zwei Schritte entfernt sind. Dieser wird berechnet als \workTodo{Paper Seite 2 unten Formel einfügen}
	\item[$c_{N(i)}$]\hfill\\ Der durchschnittliche Clustering-Koeffizient von $N(i)$, der als \workTodo{Paper Seite 2 unten Formel einfügen} berechnet wird.
	\item[$|E_{ego(i)}|$]\hfill\\ Die Anzahl der Kanten im Ego-Netzwerk vom Knoten $i$, wobei $ego(i)$ das Ego-Netzwerk von $i$ zurückgibt.
	\item[$|E^{\circ}_{ego(i)}|$]\hfill\\ Die Anzahl der von $ego(i)$ ausgehenden Kanten. 
	\item[$|N(ego(i))|$]\hfill\\ Die Anzahl von Nachbarn von $ego(i)$. 
\end{description}

\subsubsection{Aggregierung von Merkmalen}
Im nächsten Schritt wird für jeden Graphen \textit{$G_j$} eine $Knoten \times Merkmal$-Matrix $F_{G_j}$ zusammengefasst. Dieser besteht aus den Merkmalsvektoren aus Schritt 1.
Da der Vergleich von $k$-ten $F_{G_j}$ sehr aufwändig ist, wird für jede $F_{G_j}$ ein Signaturvektor $\vec{s}_{G_j}$ ausgegeben. Dieser aggregiert den Median, den Mittelwert, die Standardabweichung, die Schiefe, sowie die Kurtosis der Merkmale aus der Matrix.  

\subsubsection{Vergleich der Signaturvektoren}
\label{sec:ns-gl-cd}

Im letzten Schritt wird bei diesem Algorithmus die Canberra-Distance-Funktion als Ähnlichkeitsmaß herangezogen.

\workTodo{Canberra Distance Formel Seite 3 in Paper einfügen oder von Dictionary of Distances Chapter 17 als neue Quelle, es gibt kein Paper mit einer Beschreibung hierfür}

\workTodo{Info an Jeremy: Du könntest als Eigenarbeit weitere Distanzmetriken nutzen glaub. Hab ein Paper "Comprehensive Survey on Distance/Similarity Measures between Probability Density Functions\dq\space in dem Canberra in eine Kategorie mit Gower, Soergel, Kulczynski d, Lorentzian fällt und auch bei Netsimile wird erwähnt dass Canberra aus einer Vielzahl an Möglichkeiten gewählt wurde. }

\section{Anwendung auf Enron und Darpa Datensatz}
\workTodo{Ergebnisse der Tests aufzeigen. Vielleicht die Visualisierung mit rein bringen. Vielleicht kurz Datensätze erklären und woher die Implementierung des Algorithmus stammt.}

\section{Erweiterung des Algorithmus}
\workTodo{Erklären warum ein neues Feature benötigt wird. Vergleich des Algorithmus mit Feature und ohne neues Feature}

\section{Optimierte Implementierung des Algorithmus}
\label{sec:optiNeti}
Unter Verwendung der Netsimile Implementierung aus \autoref{sec:ns-gl}, benötigte die Ausführung des Algorithmus teilweise bis zu 30 Minuten. Aus diesem Grund wurde der Algorithmus von uns neu implementiert.  Die Laufzeit konnte dabei auf wenige Sekunden reduziert werden, indem keine Graphen Bibliothek für die Implementierung verwendet wurde. Das heißt die Netzwerke der Zeitreihe werden nicht in ein Graphen Objekt umgewandelt, sondern als Adjazenzmatrix gespeichert. Dadurch können die Features deutlich effizienter berechnet werden. Des Weiteren wurden einige Features neu eingeführt und andere entfernt, sodass lediglich Features verwendet werden die für Fully Connected Graphen geeignet sind. So hat beispielsweise das Feature $|E_{ego(i)}|$ keine Aussagekraft in einem Fully Connected Netzwerk, da jeder Knoten die gleiche Anzahl Kanten in seinem Ego Netzwerk aufweist. Deshalb wurden folgende Features verwendet:
\workTodo{Formeln ändern}
\begin{description}
	\item[$|E^{\circ}_{ego(i)}|$]\hfill\\ Arithmetisches Mittel der Kantengewichte in $ego(i)$.
	\item[$|N(ego(i))|$]\hfill\\ Geometrisches Mittel der Kantengewichte in $ego(i)$.
	\item[$|E^{\circ}_{ego(i)}|$]\hfill\\ Geometrischs Mittel 10 Prozent der höchsten Kantengewichte in $ego(i)$. 
	\item[$|E^{\circ}_{ego(i)}|$]\hfill\\ Geometrischer Mittel 20 Prozent der höchsten Kantengewichte in $ego(i)$. 
\end{description}

Von diesen Features wurde dann auch den Median, den Mittelwert, die Standardabweichung, die Schiefe, sowie die Kurtosis berechnet. \workTodo{Bin mir nicht sicher zu welchen Elementen die Canbarra Distanz berechnet wird.}. Des Weiteren wurde ein neuer Parameter eingeführt. Über diesen kann gesteuert werden zu wie vielen vorgänger Abschnitten die Distanz berechnet werden soll. Dadurch kann gesteuert werden wie schnell ein Algorithmus vergisst. Eine Auflistung der Parameter des Algorithmus ist in \autoref{table:parmeterNeti} zu sehen.

\begin{table}
	\caption{Parameter Netismile Zeitreihen}
	\label{table:parmeterNeti}
	\begin{tabular}{ |p{3cm}||p{12cm}|}
		\hline
		\textbf{Parameter}& \textbf{Beschreibung}\\
		\hline
		\hline
		Periodizität & Wie in \autoref{chap:trsnsNeti} erläutert muss die Zeitreihe in kleinere Intervalle aufgegliedert werden. Über diesen Parameter wird die Größe der Intervalle gesteuert. Für die Tests wurde der Parameter auf 288 gesetzt, da es sich hierbei um die Saisonalität der Zeitreihen handelt.\\
		\hline
		Fenstergröße & Wie in \autoref{sec:optiNeti} erklärt, bestimmt dieser Parameter die Anzahl der vorangegangenen Abschnitte zu welchen die Canberra Distanz berechnet wird. Dieser Parameter wurde für die Tests auf 5 gesetzt.\\
		\hline
		Abweichung & Legt fest ab wann es sich bei einem Abschnitt um einen Ausreißer handelt. Der Parameter wurde für die Tests auf 3 gesetzt. Bedeutet wenn der Ausreißer Score um das dreifache der Standardabweichung vom Durchschnitt abweicht, wird der Abschnitt als Ausreißer gekennzeichnet.\\
		\hline
	\end{tabular}
\end{table}

\subsubsection{Anwendung auf Zeitreihen}

Um zu untersuchen, wie gut der Algorithmus funktioniert, wurde er auf Zeitreihen getestet. Als Testdaten   wurden, ein und zweidimensionale Zeitreihen der Numenta Gruppe verwendet. Diese Zeitreihen enthalten verschiedene Ausreißer Typen, auf deren Erkennung der Algorithmus getestet wurde. Die Qualität der Ausreißererkennung wurde  mithilfe eines Punktesystem bewertet. Dabei bedeuteten 0 Punkte, Ausreißer nicht erkannt und 4 Punkte bedeuteten Ausreißer sehr gut erkannt. Die Parameter, welche für die Tests gewählt werden mussten, werden in \autoref{table:parmeterNeti} beschrieben.\\

\begin{table}
\caption{Netsimile Time Series Perfomance}
\label{table:performanceNeti}
\begin{tabular}{ |p{4.5cm}||p{4.5cm}||p{3cm}||p{3cm}|}
	\hline
	\textbf{Ausreißer Typ}& \textbf{Datei Name}&
	\textbf{1D}&\textbf{2D}\\
	\hline
	\hline
	Einzelne Peaks & anomaly-art-daily-peaks & -& -\\
	\hline
	Zunahme an Rauschen & anomaly-art-daily-increase-noise &****& ***\\
	\hline
	Signal Drift & anomaly-art-daily-drift &***& -\\
	\hline
	Kontinuierliche Zunahme der Amplitude& art-daily-amp-rise & ***& ***\\
	\hline
	Zyklus mit höherer Amplitude & art-daily-jumpsup &****& *\\
	\hline
	Zyklus mit geringerer Amplitude & art-daily-jumpsdown & ****& -\\
	\hline
	Zyklus-Aussetzer & art-daily-flatmiddle &****& ***\\
	\hline
	Signal-Aussetzer & art-daily-nojump & ****& ***\\
	\hline
	Frequenzänderung & anomaly-art-daily-sequence-change &****& ***\\
	\hline
\end{tabular}
\end{table}

\autoref{table:performanceNeti} zeigt die Ergebnisse der Tests. Es ist zu erkennen, dass die Qualität der Ausreißer-Erkennung im eindimensionalen Fall sehr gut ist. Lediglich einzelne Peaks können durch den Algorithmus nicht als Ausreißer identifiziert werden. Außerdem wird bei Signal Drifts und der kontinuierlichen Zunahme der Amplitude lediglich der Anfang des Ausreißers detektiert. Aus diesem Grund wurde eine Bewertung mit drei Sternen vergeben. Bei der Betrachtung der Graphiken in \autoref{sec:appendix_net_one} und \autoref{sec:appendix_net_two} ist zu erkennen, dass das sechste oder siebte Intervall der Zeitreihe häufig als Ausreißer markiert wird. Der Grund hierfür ist, das bei einer Fenstergröße von fünf für die ersten fünf Abschnitte kein Ausreißer Score berechnet wird. Dadurch ist die Standardabweichung zu Beginn sehr niedrig wodurch Abschnitte schnell als Ausreißer gekennzeichnet werden. Dieser Umstand wurde bei der Bewertung in \autoref{table:performanceNeti} nicht berücksichtigt. Im zweidimensionalen Fall ist die Qualität der Ausreißer-Erkennung etwas durchwachsener. Auffallend ist, dass Zyklen mit höherer und niedriger Amplitude nicht als Ausreißer erkannt werden. Insbesondere ist dies auffällig, da diese Ausreißer Typen üblicherweise zuverlässig erkannt werden (vgl. \autoref{sec:rw-gl}).  Außerdem ist der Algorithmus im zweidimensionalen Fall nicht mehr dazu in der Lage Signal Drifts zu erkennen. Andere Ausreißer Typen können durch den Algorithmus weiterhin erkannt werden, jedoch oftmals nicht mit der selben Qualität. 
