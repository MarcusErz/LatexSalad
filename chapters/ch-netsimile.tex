\newpage
\section{Netsimile}
\label{sec:ns}

\subsection{Grundlagen}
\label{ssec:ns-gl}

NetSimile ist ein skalierbarer Algorithmus zur Erkennung von Ähnlichkeiten, sowie Anomalien in Netzwerken unterschiedlicher Größen. Hierfür wird der Datensatz in gleich große Zeitintervalle unterteilt, um die daraus resultierenden Graphen auf unterschiedliche Merkmale zu untersuchen. Die Merkmale sind hierbei strukturelle Eigenschaften der einzelnen Knoten wie bspw. die Dichte eines Knotens oder die Anzahl an Nachbarn in einem Ego-Netzwerk. Die Signatur ergibt sich aus den einzelnen Aggregationen der Knoten wie bspw. der Median aus der Dichte der jeweiligen Knoten. So entsteht bspw. aus sieben Merkmalen und fünf Aggregationen ein Signaturvektor mit 35 verschiedenen Signaturen. So ermöglicht der Signarturvektor die Beschreibung als auch den Vergleich der einzelnen Graphen. Für den Vergleich wird die Canberra Distanz aus den beiden Signaturvektoren zweier zeitlich nebeneinander liegenden Graphen berechnet. \citep[vgl.][S.~1]{Netsimile}

Als Input für diesen Algorithmus wird eine Menge von $k$-anonymisierten Netzwerken mit beliebig unterschiedlichen Größen, die keine überlappenden Knoten oder Kanten besitzen sollten, herangezogen werden. Das Resultat sind Werte für die strukturelle Ähnlichkeit oder Abstands eines jeden Paares der gegebenen Netzwerke bzw. ein Merkmalsvektor für jedes Netzwerk. \citep[vgl.][S.~1]{Netsimile}

NetSimile durchläuft drei Schritte, die im Folgenden erläutert werden.

\subsubsection{Extrahierung von Merkmalen}
Für jeden Knoten $i$ werden, basierend auf ihren Ego-Netzwerken, die folgenden Merkmale generiert:


\begin{description}
	\item[$\overline{d}_i = |N(i)|$]\hfill\\ Die Anzahl der Nachbarn (d.h. Grad) von Knoten $i$, wobei $N(i)$ die Nachbarn von Knoten $i$ beschreibt.
	\item[$\overline{c}_i$]\hfill\\ Der Clustering-Koeffizient von Knoten $i$, der als die Anzahl von Dreiecken, die mit Knoten $i$ verbunden sind, über die Anzahl von verbundenen Dreiecken, die auf Knoten $i$ zentriert sind, definiert ist.
	\item[$d_{N(i)}$]\hfill\\ Die durchschnittliche Anzahl der Nachbarn von Knoten $i$, die zwei Schritte entfernt sind. Dieser wird berechnet als \workTodo{Paper Seite 2 unten Formel einfügen}
	\item[$c_{N(i)}$]\hfill\\ Der durchschnittliche Clustering-Koeffizient von $N(i)$, der als \workTodo{Paper Seite 2 unten Formel einfügen} berechnet wird.
	\item[$|E_{ego(i)}|$]\hfill\\ Die Anzahl der Kanten im Ego-Netzwerk vom Knoten $i$, wobei $ego(i)$ das Ego-Netzwerk von $i$ zurückgibt.
	\item[$|E^{\circ}_{ego(i)}|$]\hfill\\ Die Anzahl der von $ego(i)$ ausgehenden Kanten. 
	\item[$|N(ego(i))|$]\hfill\\ Die Anzahl von Nachbarn von $ego(i)$. 
\end{description}

\subsubsection{Aggregierung von Merkmalen}
Im nächsten Schritt wird für jeden Graphen \textit{$G_j$} eine $Knoten \times Merkmal$-Matrix $F_{G_j}$ zusammengefasst. Dieser besteht aus den Merkmalsvektoren aus Schritt 1.
Da der Vergleich von $k$-ten $F_{G_j}$ sehr aufwändig ist, wird für jede $F_{G_j}$ ein Signaturvektor $\vec{s}_{G_j}$ ausgegeben. Dieser aggregiert den Median, den Mittelwert, die Standardabweichung, die Schiefe, sowie die Kurtosis der Merkmale aus der Matrix.  

\subsubsection{Vergleich der Signaturvektoren}
\label{sec:ns-gl-cd}

Für die Ausreißererkennung werden die letzten drei Graphen anhand der Canberra-Distanz-Funktion, die als Ähnlichkeitsmaß dient, herangezogen. Steigt die Canberra Distanz zwischen zwei Graphen oberhalb des Thresholds so wird dies im Algorithmus festgehalten. Falls der darauf folgende Graph ebenfalls oberhalb des Thresholds liegt, so wird dieser als Ausreißer definiert. Dadurch wird die Anzahl der Ausreißer reduziert, damit nur diejenigen identifiziert werden, bei denen ein Trend hin zu einem abnormalen Verhalten erkennbar ist.

Der Algorithmus arbeitet dabei dynamisch, da die Signaturen der Graphen in einzelne Teil-Berechnungen aufgesplittet und zwischengespeichert werden können, ohne das eine Neuberechnung notwendig ist. Der Threshold wird aus dem Median und dem Mean berechnet, welche ebenfalls Zwischengespeichert werden können und nach Bedarf um weitere Graphen ergänzt werden können.

\FloatBarrier

\subsection{Erweiterung des Algorithmus}
Damit der Algorithmus auf Netzwerke angewendet werden kann, muss dieser vorab erweitert werden, da in Netzwerken ansonsten nur die Verbindung im Allgemeinen betrachtet wird, nicht aber die Häufigkeit an Verbindungen, die zwischen zwei Knoten stattgefunden hat. Damit würde ein großer Anteil des Datensatzes verloren gehen, da der Algorithmus keine Mehrfach-Verbindungen zwischen Knoten im Graphen darstellen kann.
\\
\\
Hierfür werden die Mehrfach-Verbindungen aufsummiert und als Kanten-Gewichtung zwischen zwei Knoten dem Graphen hinzugefügt.
\begin{lstlisting}[language=Python, caption=Gewichtung als neues Feature, label=lst:netsimile:code1]
for i in range(len(e_list)): 
	g.add_edge(e_list[i][0], e_list[i][1], weight=e_list[i][2])
\end{lstlisting}
Anschließend muss die Gewichtung aus diesem Graphen extrahiert werden. Dafür wird die Summe aller ausgehenden Kanten eines Knotens gebildet und als Feature hinzugefügt. 
\\
\\
Für die Anwendung des Algorithmus auf Zeitreihen ist die Erweiterung um das Feature Gewichtung ebenfalls relevant, da sonst der Algorithmus auf einen vollständigen Graphen angewendet wird.

\begin{figure}
	\centering
	\includegraphics[height=0.5\linewidth,width=\linewidth]{fig/netsimile/graph_11}
	\caption{Vollständiger Graph mit 11 Knoten}
	\label{img:netsimile:graph_11}
\end{figure}

Das Problem hierbei ist, dass jeder Knoten eines Graphens die gleichen Features beinhalten würde. Dadurch würden die Aggregationen überflüssig werden und der Signaturvektor auf sieben Features schrumpfen. Die Bildung von Cluster-Features wäre demnach nur noch bedingt möglich und die Betrachtung an Nachbarn, unabhängig ob im Ego-Netzwerk oder im gesamten Netzwerk würde sich die Gesamtanzahl an Knoten annähern. Im Folgenden wird das Verhältnis der Features zum Durchschnitt dargestellt.

\begin{figure}
	\centering
	\includegraphics[height=0.8\linewidth,width=\linewidth]{fig/netsimile/heatmap_1}
	\caption{Signaturvektoren der Zeitreihe mit vollständigen Graphen}
	\label{img:netsimile:heatmap_1}
\end{figure}

Man erkennt gut, dass die Features der einzelnen Graphen identisch sind, weshalb die Graphen denselben Threshold haben und somit den Wert 0 teilen. 
\\


\begin{figure}
	\centering
	\includegraphics[height=0.6\linewidth,width=\linewidth]{fig/netsimile/anomalie_1}
	\caption{Ausreißer Score der vollständigen Graphen}
	\label{img:netsimile:anomalie_1}
\end{figure}

Dadurch ist die Ausreißererkennung von Zeitreihen in Graphen nicht möglich. Fügt man die Gewichtung als weiteres Feature hinzu, wird hier eine erste Betrachtung der Ausreißer möglich. Der Graph 10 wird hier wie erhofft als Ausreißer identifiziert.

\begin{figure}
	\centering
	\includegraphics[height=0.6\linewidth,width=\linewidth]{fig/netsimile/anomalie_2}
	\caption{Ausreißer Score der vollständigen Graphen mit gewichteten Kanten}
	\label{img:netsimile:anomalie_2}
\end{figure}

\workTodo{Struktur - Subsubsection}

\FloatBarrier

\subsubsection{Netzwerk}
\label{sec:netsimile:netzwerk}

\paragraph{\textbf{Enron}}

\begin{figure}
	\centering
	\includegraphics[height=0.6\linewidth,width=\linewidth]{fig/netsimile/anomalie_3}
	\caption{Ausreißer Score Enron Datensatz}
	\label{img:netsimile:anomalie_3}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[height=0.8\linewidth,width=\linewidth]{fig/netsimile/heatmap_3}
	\caption{Darstellung der Ausreißer in Heatmaps}
	\label{img:netsimile:heatmap_3}
\end{figure}

\begin{itemize}
	\item Ausreißer werden erkannt
	\item \workTodo{Dauer Berechnung}
\end{itemize}

\FloatBarrier

\paragraph{\textbf{Darpa}}

\begin{figure}
	\centering
	\includegraphics[height=0.6\linewidth,width=\linewidth]{fig/netsimile/anomalie_4}
	\caption{Ausreißer Score DARPA}
	\label{img:netsimile:anomalie_4}
\end{figure}


\begin{itemize}
	\item Ausreißer werden wahrgenommen
	\item Dauer Berechnung: 11150.692071 seconds
\end{itemize}


\FloatBarrier
\subsubsection{Zeitreihendaten}
\label{sec:netsimile:zeitreihen}

\workTodo{Beschreibung als Fließtext, Verweise noch einfügen zu den Bildern}

\begin{table}
	\caption{Ursprünglicher Netismile Performance}
	\label{table:performanceNeti}
	\begin{tabular}{ |p{3.5cm}||p{3.5cm}||p{2.5cm}||p{2.5cm}||p{2.5cm}|}
		\hline
		\textbf{Ausreißer Typ}& \textbf{Datei Name}&
		\textbf{1D}&\textbf{Beschreibung}&\textbf{Laufzeit}\\
		\hline
		\hline
		Einzelne Peaks & anomaly-art-daily-peaks & **& Zwei gemeinsame Peaks werden erkannt, Einzelne eher schlecht
		&61min\\
		\hline
		Zunahme an Rauschen & anomaly-art-daily-increase-noise &****& Ausreißer wird erkannt&51\\
		\hline
		Signal Drift & anomaly-art-daily-drift &**& Nur zwei von vier Ausreißer werden erkannt
		Die letzten zwei werden also normal definiert
		&57min\\
		\hline
		Kontinuierliche Zunahme der Amplitude& art-daily-amp-rise & ****& Ausreißer werden erkannt
		&54min\\
		\hline
		Zyklus mit höherer Amplitude & art-daily-jumpsup &****& Ausreißer werden erkannt
		&50\\
		\hline
		Zyklus mit geringerer Amplitude & art-daily-jumpsdown & ****& Ausreißer werden erkannt
		&51min\\
		\hline
		Zyklus-Aussetzer & art-daily-flatmiddle &****& Ausreißer werden erkannt
		&62min\\
		\hline
		Signal-Aussetzer & art-daily-nojump & ****& Ausreißer werden erkannt
		&65min\\
		\hline
		Frequenzänderung & anomaly-art-daily-sequence-change &****& Ausreißer werden erkannt
		&49min\\
		\hline
	\end{tabular}
\end{table}

\paragraph{\textbf{Eindimensional}}



\paragraph{\textbf{Mehrdimensional}}

Probleme
\begin{itemize}
	\item es werden Knoten generiert die gar nicht existieren im Datensatz
\end{itemize}
\subsection{Optimierte Implementierung des Algorithmus}
\label{sec:optiNeti}
Unter Verwendung der Netsimile Implementierung aus \autoref{sec:ns-gl}, benötigte die Ausführung des Algorithmus teilweise bis zu 30 Minuten. Aus diesem Grund wurde der Algorithmus von uns neu implementiert.  Die Laufzeit konnte dabei auf wenige Sekunden reduziert werden, indem keine Graphen Bibliothek für die Implementierung verwendet wurde. Das heißt die Netzwerke der Zeitreihe werden nicht in ein Graphen Objekt umgewandelt, sondern als Adjazenzmatrix gespeichert. Dadurch können die Features deutlich effizienter berechnet werden. Des Weiteren wurden einige Features neu eingeführt und andere entfernt, sodass lediglich Features verwendet werden die für Fully Connected Graphen geeignet sind. So hat beispielsweise das Feature $|E_{ego(i)}|$ keine Aussagekraft in einem Fully Connected Netzwerk, da jeder Knoten die gleiche Anzahl Kanten in seinem Ego Netzwerk aufweist. Deshalb wurden folgende Features verwendet:
\workTodo{Formeln ändern}
\begin{description}
	\item[$|E^{\circ}_{ego(i)}|$]\hfill\\ Arithmetisches Mittel der Kantengewichte in $ego(i)$.
	\item[$|N(ego(i))|$]\hfill\\ Geometrisches Mittel der Kantengewichte in $ego(i)$.
	\item[$|E^{\circ}_{ego(i)}|$]\hfill\\ Geometrischs Mittel 10 Prozent der höchsten Kantengewichte in $ego(i)$. 
	\item[$|E^{\circ}_{ego(i)}|$]\hfill\\ Geometrischer Mittel 20 Prozent der höchsten Kantengewichte in $ego(i)$. 
\end{description}

Von diesen Features wurde dann auch den Median, den Mittelwert, die Standardabweichung, die Schiefe, sowie die Kurtosis berechnet. \workTodo{Bin mir nicht sicher zu welchen Elementen die Canbarra Distanz berechnet wird.}. Des Weiteren wurde ein neuer Parameter eingeführt. Über diesen kann gesteuert werden zu wie vielen vorgänger Abschnitten die Distanz berechnet werden soll. Dadurch kann gesteuert werden wie schnell ein Algorithmus vergisst. Eine Auflistung der Parameter des Algorithmus ist in \autoref{table:parmeterNeti} zu sehen.

\begin{table}
	\caption{Parameter Netismile Zeitreihen}
	\label{table:parmeterNeti}
	\begin{tabular}{ |p{3cm}||p{12cm}|}
		\hline
		\textbf{Parameter}& \textbf{Beschreibung}\\
		\hline
		\hline
		Periodizität & Wie in \autoref{sec:trsnsNeti} \workTodo{Referenz sollte glaube ich autoref -> sec:trsnsNeti sein} erläutert muss die Zeitreihe in kleinere Intervalle aufgegliedert werden. Über diesen Parameter wird die Größe der Intervalle gesteuert. Für die Tests wurde der Parameter auf 288 gesetzt, da es sich hierbei um die Saisonalität der Zeitreihen handelt.\\
		\hline
		Fenstergröße & Wie in \autoref{sec:optiNeti} erklärt, bestimmt dieser Parameter die Anzahl der vorangegangenen Abschnitte zu welchen die Canberra Distanz berechnet wird. Dieser Parameter wurde für die Tests auf 5 gesetzt.\\
		\hline
		Abweichung & Legt fest ab wann es sich bei einem Abschnitt um einen Ausreißer handelt. Der Parameter wurde für die Tests auf 3 gesetzt. Bedeutet wenn der Ausreißer Score um das dreifache der Standardabweichung vom Durchschnitt abweicht, wird der Abschnitt als Ausreißer gekennzeichnet.\\
		\hline
	\end{tabular}
\end{table}


\subsubsection{Ausreißer-Erkennung in Zeitreihen}
Um zu untersuchen, wie gut der Algorithmus funktioniert, wurde er auf Zeitreihen getestet. Als Testdaten   wurden, ein und zweidimensionale Zeitreihen der Numenta Gruppe verwendet. Diese Zeitreihen enthalten verschiedene Ausreißer Typen, auf deren Erkennung der Algorithmus getestet wurde. Die Qualität der Ausreißererkennung wurde  mithilfe eines Punktesystem bewertet. Dabei bedeuteten 0 Punkte, Ausreißer nicht erkannt und 4 Punkte bedeuteten Ausreißer sehr gut erkannt. Die Parameter, welche für die Tests gewählt werden mussten, werden in \autoref{table:parmeterNeti} beschrieben.\\

\begin{table}
\caption{Netsimile Time Series Perfomance}
\label{table:performanceNeti}
\begin{tabular}{ |p{4.5cm}||p{4.5cm}||p{3cm}||p{3cm}|}
	\hline
	\textbf{Ausreißer Typ}& \textbf{Datei Name}&
	\textbf{1D}&\textbf{2D}\\
	\hline
	\hline
	Einzelne Peaks & anomaly-art-daily-peaks & -& -\\
	\hline
	Zunahme an Rauschen & anomaly-art-daily-increase-noise &****& ***\\
	\hline
	Signal Drift & anomaly-art-daily-drift &***& -\\
	\hline
	Kontinuierliche Zunahme der Amplitude& art-daily-amp-rise & ***& ***\\
	\hline
	Zyklus mit höherer Amplitude & art-daily-jumpsup &****& *\\
	\hline
	Zyklus mit geringerer Amplitude & art-daily-jumpsdown & ****& -\\
	\hline
	Zyklus-Aussetzer & art-daily-flatmiddle &****& ***\\
	\hline
	Signal-Aussetzer & art-daily-nojump & ****& ***\\
	\hline
	Frequenzänderung & anomaly-art-daily-sequence-change &****& ***\\
	\hline
\end{tabular}
\end{table}

\autoref{table:performanceNeti} zeigt die Ergebnisse der Tests. Es ist zu erkennen, dass die Qualität der Ausreißer-Erkennung im eindimensionalen Fall sehr gut ist. Lediglich einzelne Peaks können durch den Algorithmus nicht als Ausreißer identifiziert werden. Außerdem wird bei Signal Drifts und der kontinuierlichen Zunahme der Amplitude lediglich der Anfang des Ausreißers detektiert. Aus diesem Grund wurde eine Bewertung mit drei Sternen vergeben. Bei der Betrachtung der Graphiken in \autoref{sec:appendix_net_one} und \autoref{sec:appendix_net_two} ist zu erkennen, dass das sechste oder siebte Intervall der Zeitreihe häufig als Ausreißer markiert wird. Der Grund hierfür ist, das bei einer Fenstergröße von fünf für die ersten fünf Abschnitte kein Ausreißer Score berechnet wird. Dadurch ist die Standardabweichung zu Beginn sehr niedrig wodurch Abschnitte schnell als Ausreißer gekennzeichnet werden. Dieser Umstand wurde bei der Bewertung in \autoref{table:performanceNeti} nicht berücksichtigt. Im zweidimensionalen Fall ist die Qualität der Ausreißer-Erkennung etwas durchwachsener. Auffallend ist, dass Zyklen mit höherer und niedriger Amplitude nicht als Ausreißer erkannt werden. Insbesondere ist dies auffällig, da diese Ausreißer Typen üblicherweise zuverlässig erkannt werden (vgl. \autoref{sec:rw-gl}).  Außerdem ist der Algorithmus im zweidimensionalen Fall nicht mehr dazu in der Lage Signal Drifts zu erkennen. Andere Ausreißer Typen können durch den Algorithmus weiterhin erkannt werden, jedoch oftmals nicht mit der selben Qualität. 

\FloatBarrier

