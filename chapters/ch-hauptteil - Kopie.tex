% Bsp. eines Hauptteils

\chapter{Grundlagen}
\label{chap:grundl}
Die Radarsensoren (siehe \autoref{sec:grundl-radar}) der \workFirma werden nach der Produktion verschiedenen Tests unterzogen. Zu diesen Test gehören unter anderem das testen der Leiterplatine, des Gehäuses, des Mikrokontrollers (siehe \autoref{sec:grundl-uC}), die Antennen und Funktionstests bei Extremtemperaturen. Um den MC und dessen Komponenten zu testen, wird eine Testsoftware benötigt, die diese Tests auf dem MC ausführt und die Ergebnisse dem Prüfautomaten (siehe \autoref{sec:grundl-pruefaut}) sendet. Für diese Tests wird eine in C/C++ geschriebene Testsoftware STIL verwendet, bestehend aus dem Betriebssystem STILCore (siehe \autoref{sec:grundl-bs}) und den Testprogrammen STILRoutine (siehe \autoref{sec:grundl-routine}). In der Produktion ruft der Prüfautomat mithilfe des KWP2000-Protokolls (siehe \autoref{sec:grundl-tswkwp}) die Test Services auf. Der Radarsensor sendet nach Beendigung des Test Services eine Antwort die vom Prüfautomaten ausgewertet wird. Die Antwort des Sensors ist ausschlaggebend dafür, ob es sich dabei um einen fehlerhaften Sensor handelt oder ob der Test erfolgreich war.
\workTodo{verbessern}

\section{Radarsensor}
\label{sec:grundl-radar}
Die \workFirma stellt eine vielfältige Auswahl an Radarsensoren für den Automotive Bereich her. Sie werden nach Varianten, Einbauposition und Generation unterteilt. Zurzeit wird die Generation 5 des Radarsensors entwickelt. Die Anwendungsfälle spezifizieren die Einbauposition im Fahrzeug. Die Variante des Sensors bestimmt dessen Leistungsfähigkeit und Funktionsumfang. Es gibt dabei Base, Plus und Premium Varianten. Für diese \workTyp ist nur die Variante des Sensors relevant, da zur Zeit nur an der Generation 5 gearbeitet wird und die Einbauposition keinen Einfluss auf die Testsoftware hat.
\newpage
\section{Mikrokontroller Infineon TC-3xx}
\label{sec:grundl-uC}
Die MCs der Infineon AURIX TC-3xx Familie sind leistungsstarke multicore MC für Embedded-Systeme mit mehreren TriCore CPUs, Programm- und Datenspeichern, Bussen und einer vielzahl von Peripherien. Sie wird oft in den Steuergeräten im Automotive-Bereich verwendet aufgrund seiner Echtzeitfähigkeit, Integrierten DSP-Operationen, hohem Datendurchsatz und Energieeffizienz. \workTodo{verweis auf TC-3XX Datenblatt}

\subsection{TriCore CPU Architektur}
\label{sec:grundl-arch-cpu}
Die TriCore CPUs bauen auf der TriCore V1.6 Architektur der Firma Infineon auf. Wesentliche Eigenschaften der TriCore Architektur sind:\workTodo{Verweis auf TriCore Arch. Man.}
\begin{itemize}
	\item Ein-Kern CPU
	\item 32-Bit Mikrokontroller
	\item integrierte DSP-Einheit
	\item RISC Load/Store Architektur
	\item optimiert für Embedded Echtzeitsysteme
	\item 4GByte Adressbereich
	\item Debug Schnittstelle
\end{itemize}

Eine Besonderheit dieser CPUs sind die Lockstep Kerne. Die meisten CPUs im MC besitzen zusätzlich zum normalen Kern einen Lockstep Kern. Diese führt genau dieselbe Operation des normalen Kerns aus. Treten Unterschiede in den Ergebnissen der Kerne auf, muss ein Hardwarefehler bei einer der beiden aufgetreten sein. Dies wird der Safety Management Unit gemeldet und je nach Konfiguration ein Reset oder ein Interrupt ausgelöst.

\subsection{OnChip Verbindungen}
Mithilfe des System Ressource Interconnect Fabric (SRI), System Peripheral Bus (SPB) und dem Backbone Bus (BBB) werden die verschiedenen Komponenten des MCs miteinander verknüpft. Da der Backbone Bus nicht in dieser \workTyp genutzt wird, wird dieser nicht behandelt.

\subsubsection{System Ressource Interconnect Fabric (SRI)}
Das SRI Fabric ist ein Geflecht aus Bussen, das verwendet wird um die Master und Slave Komponenten, die eine hohe Bandbreite und hohen Datendurchsatz benötigen, miteinander zu verbinden. Es hat eine gitterähnliche Struktur mit Master Komponenten auf einer Seite und Slave Komponenten auf der anderen. An den Kreuzpunkten der Busse können die Leiterbahnen je nach Verbindung miteinander Verknüpft werden. Die Master Komponenten können Transaktionen ausführen, die Slave hingegen nur auf Transaktionen reagieren und antworten. Master Komponenten am SRI Fabric sind unter anderem die TriCore CPUs, DMA Modul und HSSL und Slave Komponenten sind die verschiedenen Speicher, der SPB und BBB. Zusätzlich gibt es noch Bridges, die als Master und Slave agieren. Diese werden zur Verknüfung von zwei SRI Fabrics verwendet, da aufgrund der Anzahl an Komponenten es nicht möglich ist alle Komponenten mithilfe einer SRI Fabric zu verbinden.\workTodo{Bild mit SRI Fabric geflecht und verweis auf TC Datenblat}

\subsubsection{System Peripheral Bus (SPB)}
\workTodo{SPB schreiben}

\subsection{Speichersystem}
\label{sec:grundl-memory-sys}
Das Speichersystem der Infineon AURIX TC-3XX Familie besteht aus einem einzigen zusammenhängenden Adressraum. Jedoch gibt es keinen zentralen Speicher, sondern sie sind in den verschiedenen Komponenten verteilt und direkt oder über Busse zugänglich. Dies hat den Vorteil, dass die Komponenten des Systems kurze Zugriffzeiten auf die eigenen Speicher haben und zugleich ihnen der Zugriff auf fremde Speicherzellen über einen Bus möglich bleibt. Infolgedessen führt der Zugriff auf fremde Speicherzellen über einen Bus zu längeren Zugriffszeiten. Solche Speichersysteme werden Non-Uniform Memory Access, kurz NUMA, genannt, da sie keine einheitliche Zugriffszeit auf Speicher gewähren. \workTodo{verweis auf Springer Buch}

Der Adressraum umfasst 4GB und ist in 16 gleichgroße Segmente unterteilt. Die ersten 4Bits der Adresse bestimmen, in welchem Segment der Speicherzugriff erfolgt. Die Segmente bestimmen, auf welche Art und welchen Speicher zugegriffen wird. In der \autoref{tab:mem-uC} sind die einzelnen Segmente und deren Funktion aufgezeigt.

\begin{table}[H]
	\caption{Speichersegmente}
	\centering
	\renewcommand\arraystretch{1.5}
	\begin{tabular}{p{0.10\linewidth}>{\centering\arraybackslash}p{0.30\linewidth}>{\centering\arraybackslash}p{0.50\linewidth}}
		\toprule
		Segment&Adressbereich (Hexadezimal)&Funktion\\
		\midrule
		0&0000 0000 - 0FFF FFFF& Reserviert\\
		\midrule
		1&1000 0000 - 1FFF FFFF& CPU5 DSPR, PSPR \& Cache\\
		\midrule
		2&2000 0000 - 2FFF FFFF& Reserviert\\
		\midrule
		3&3000 0000 - 3FFF FFFF& CPU4 DSPR, PSPR \& Cache\\
		\midrule
		4&4000 0000 - 4FFF FFFF& CPU3 DSPR, PSPR \& Cache\\
		\midrule
		5&5000 0000 - 5FFF FFFF& CPU2 DSPR, PSPR \& Cache\\
		\midrule
		6&6000 0000 - 6FFF FFFF& CPU1 DSPR, PSPR \& Cache\\
		\midrule
		7&7000 0000 - 7FFF FFFF& CPU0 DSPR, PSPR \& Cache\\
		\midrule
		8&8000 0000 - 8FFF FFFF& Cached PFLASH, Boot ROM, OLDA \& Ext. Bus\\
		\midrule
		9&9000 0000 - 9FFF FFFF& Cached LMU, DAM, TRAM \& EMEM\\
		\midrule
		10&A000 0000 - AFFF FFFF& Non-cached PFLASH, PFI Register, DFLASH, OLDA \& Ext. Bus\\
		\midrule
		11&B000 0000 - BFFF FFFF& Non-cached LMU, DAM, TRAM, EMEM \& XTM\\
		\midrule
		12&C000 0000 - CFFF FFFF& Lokaler Zugriff auf PSPR\\
		\midrule
		13&D000 0000 - DFFF FFFF& Lokaler Zugriff auf DSPR\\
		\midrule
		14&E000 0000 - EFFF FFFF& Reserviert\\
		\midrule
		15&F000 0000 - FFFF FFFF& SPB und SRI Adressraum\\
		\bottomrule
	\end{tabular}
	\label{tab:mem-uC}
\end{table}

Der MC besitzt eine vielzahl an Speicher. Einige dieser Speicher werden nicht behandelt, da sie nicht relevant für diese \workTyp sind. Eine ausführlichere Erklärung kann im Datenblatt des MCs nachgeschlagen werden. \workTodo{Verweis auf MC datenbaltt}

\subsubsection{RAM}
Die TC-3xx Serie besitzt für jede TriCore CPU einen lokalen RAM. Basierend nach der Harvard-Architektur\workTodo{Verweis CA by hennesy\&patterson} ist dieser RAM unterteilt in Code- und Datenspeicher (PSPR und DSPR). Die CPUs können über den Systembus auf die RAM-Speicher der anderen CPUs zugreifen. In dieser \workTyp wird nur der DSPR verwendet, da das bisherige Betriebssystem nur diesen verwendet.

\subsubsection{Programmflash Speicher}
Der Programmflash (PFLASH) ist ein nichtflüchtiger Speicher, der Programmcode und Daten enthält. Das Betriebssystem und die meisten Testroutinen sind im PFLASH gespeichert und werden von dort aus ausgeführt. Der Zugriff darauf kann mit oder ohne Cache erfolgen, je nachdem über welchen Adressbereich der Zugriff erfolgt.

\subsubsection{Cache}
Die CPUs besitzen jeweils einen eigenen Daten- und Programmcache. Der Cache ist ein schneller Speicher, der mit Programmcode und Daten geladen wird, welcher spekulativ als nächstes benötigt werden könnten. Er ist nicht auf alle Speicherbereiche anwendbar. Der PFLASH, die DSPRs und PSPRs anderer CPUs können, je nach Konfiguration und Adressierung, gecached werden, um längere Speicherzugriffszeiten zu vermeiden. Zu beachten gilt hierbei, dass die Caches der CPUs keine kohärenten Caches sind.
\newpage
\subsection{Unterschiede der Mikrokontroller Varianten}
\label{sec:grundl-uC-unterschiede}
Je nach Variante werden verschiedene Modelle der MCs eingesetzt. Die MCs sind speziell für den Automotive Bereich entwickelte Embedded MCs und unterscheiden sich haupstächlich durch die Anzahl der CPUs und Größe des Flash- und RAM-Speichers. Bei der \workFirma werden die MCs als XL-, L-, M- und S-Device bezeichnet. Die \autoref{tab:eig-uC} zeigt den Zusammenhang zwischen den MCs und den Varianten und dessen Eigenschaften. Die \autoref{tab:eig-uC} betrachtet dabei nur Komponenten der MCs, die relevant für diese \workTyp sind. \workTodo{Hier verweis auf Bosch dokumente}

\begin{table}[H]
	\caption{Eigenschaften der MC Modelle}
	\centering
	\renewcommand\arraystretch{1.5}
	\begin{tabular}{p{0.20\linewidth}*{4}{>{\centering\arraybackslash}p{0.16\linewidth}}}
		\toprule
		&XL-Device&L-Device&M-Device&S-Device\\
		\midrule
		Name: &TC397XA-256F300S&TC397QA-160F300S&TC357TA-64F300S&TC337DA-32F300S\\
		\midrule
		Anzahl CPUs:&6&4&3&2\\
		davon Lockstep:&4&3&2&1\\
		\midrule
		PSPR pro CPU: &64kB&64kB&64kB&32kB(CPU0) 64kB(CPU1)\\
		DSPR pro CPU: &240kB(CPU0\&1) 96kB&240kB(CPU0\&1) 96kB&240kB(CPU0\&1) 96kB&196kB(CPU0) 96kB(CPU1)\\
		DLMU pro CPU: &64kB&64kB&64kB&8kB(CPU0) 64kB(CPU1)\\
		LMU Global: &768kB&512kB&512kB&0kB\\
		DAM Global: &128kB&0kB&0kB&0kB\\
		SRAM gesamt: &2528kB&1696kB&1472kB&456kB\\
		\bottomrule
	\end{tabular}
\label{tab:eig-uC}
\end{table}
\newpage
\section{Betriebsystem STILCore}
\label{sec:grundl-bs}
Die vollständige Testsoftware besteht aus einem Betriebssystem (STILCore) und den Testprogrammen (STILRoutinen siehe \autoref{sec:grundl-routine}). Dabei ist das STILCore spezifisch nur für Testzwecke gedacht und wird bei der Anwendung im Fahrzeug nicht genutzt. Es lässt sich nur mithilfe eines speziellen Signals (ESB) auf dem CAN-Bus starten. Das ESB ist ein Signal, welches nie auf einem CAN-Bus im Fahrzeug anliegen dürfte, so das ein ungewollter Boot in den STILCore nicht möglich ist. Zu den Aufgaben des STILCores gehören das dynamische Speichermanagement, die Bereitstellung von Treibern, Flashen von neuer Software, Kommunikation mit dem Prüfautomaten über CAN und das Ausführen von STILRoutinen.

Das STILCore ist Modular aufgebaut, so dass jedes Modul eine spezifische Aufgabe hat. Eine hierarchische Modulübersicht wird in \autoref{img:tswmodule} aufgezeigt. In den nachfolgenden Kapiteln werden die einzelnen Aufgaben der Module und deren Funktionsweise genauer erläutert.
\begin{figure}
	\centering
	\includegraphics[width=5cm]{fig/tswmodule}
	\caption{Module des STILCores}
	\label{img:tswmodule}
\end{figure}
\subsection{Speichermanagement}
\label{sec:grundl-tswmem}
Das Speichermanagement Modul wird tswmem bezeichnet. Sie wird zum allokieren und freigeben von Speicher im DSPR verwendet. Intern nutzt das tswmem Modul eine Tabelle zum verwalten der allokierten Speicherbereiche.

Das \workTodo{Hier verweis auf Heap mit MemTab} zeigt auf, wie die Struktur des DSPRs aussieht, nachdem das tswmem Modul die Memory Table initialisiert hat. Am Anfang des DSPRs befinden sich Speicherbereiche wie der Interrupt Stack, User Stack und Context Save Area. Daraufhin folgt der Heap, der von der tswmem verwaltet wird. Die Tabelle, die Informationen über allokierte und freie Bereiche enthält, befindet sich am Ende des Heaps. Wenn ein Speicher allokiert werden soll, wird ein Eintrag in der Tabelle erstellt, der die Start- und Endadresse des allokierten Speichers enthält. Als Rückgabewert wird ein Pointer, der auf diesen Speicher zeigt, zurückgegeben. Es erfolgt keine Zugriffsüberwachung auf den Heap. \workTodo{umschreiben}

\subsection{Bereitstellung von Treibern}
\label{sec:grundl-tswdrv}
Das tswdrv Modul stellt verschiedene Treiber zur Verfügung die vom STILCore und den STILRoutinen benötigt werden. 

\subsubsection{ESB Treiber}
Mit dem ESB Treiber im tswdrv Modul ist es möglich, ein ESB-Signal auf dem CAN-Bus zu erkennen und auf dessen Ende zu warten. Das STILCore nutzt diesen Treiber beim Start des Sensors und wartet zwei Sekunden lang auf ein ESB-Signal. Wird keines erkannt, beendet sich das STILCore selbst und übergibt die Kontrolle wieder dem Bootmanager.

\subsubsection{CAN-Treiber}
Der CAN-Treiber wird zur Kommunikation über den CAN-Bus benötigt. Dabei ist zu beachten, dass nicht 
\subsection{KWP2000-Protokoll}
\label{sec:grundl-tswkwp}
Das STILCore nutzt zur Kommunikation mit dem Prüfautomaten ein Protokoll Namens KWP2000, die in \workTodo{ISO14230} definiert ist. Das KWP2000 basiert auf dem ISO/OSI\workTodo{ISO Nummer} Schichtenmodell und wird für Diagnose Systeme auf seriellen Datenverbindungen genutzt. Als Übertragungsmedium wird die CAN-Schnittstelle des MCs verwendet. \workTodo{ISO15765} 

Aufgrund der Definition in \workTodo{Referenz} muss das KWP2000 Protokoll über die Data Link Layer (tswtp) und Application Layer (tswkwp) des OSI-Schichtenmodells implementiert werden.
\workTodo{sollte auf das KWP-Protokoll genauer eingegangen werden?}

%\subsection{Authentifizierung}
%\label{sec:grundl-auth}
%Zum Schutz vor unerlaubtem Zugriff auf das STILCore werden verschiedene Authentifizierungsverfahren verwendet. Aufgrund des Umfangs und der Sicherheitsanforderungen wird nicht weiter auf das Authentifizierungsverfahren eingegangen. Es kann angenommen werden, dass die Radarsensoren keine Authentifizierung implementieren.

\section{Testprogramme STILRoutine}
\label{sec:grundl-routine}
STILRoutinen sind die Testprogramme, die vom STILCore ausgeführt werden. Auf einem Sensor können mehrere STILRoutinen geflasht werden. Dabei ist ein Testprogramm für eine bestimmte Peripherie bestimmt. Verschiedene Funktionen einer Peripherie können mihilfe von Services einer STILRoutine getestet werden.

\section{Prüfautomat}
\label{sec:grundl-pruefaut}
Der Prüfautomat ist ein \workTodo{was genau ist der Prüfautomat?!}. Er ist für die Prüfung des Radarsensors über das KWP2000 zuständig. Dazu installiert er die benötigten Testprogramme und sendet eine Anforderung zur Ausführung entsprechender Tests. Nachdem der Sensor einen Test abgeschlossen hat, wird die Antwort des Sensors vom Prüfautomaten ausgewertet und entschieden ob der Test erfolgreich war.

\section{STILTool}
\label{sec:grundl-stiltool}
Das STILTool ist ein von der \workFirma entwickeltes Windows-Programm zur Ausführung von verschiedenen Testservices mithilfe eines PCs. Das Programm ermöglicht das testen von der Testsoftware vor Ort bevor sie an die Produktion ausgeliefert wird. Außerdem bietet es die Funktion einen Sensor auf einen neuen Softwarestand zu flashen.

\section{V-Modell}
\label{sec:grundl-vmodell}

\chapter{Entwurf des neuen Betriebssystems}
\label{chap:model}
Bei der Entwicklung der Erweiterung für das STILCore wird die V-Model Entwicklungsmethode angewendet. Zu allererst müssen die Anforderungen und Use-Cases an das neue STILCore genauer spezifiziert werden. Dazu werden die Mitarbeiter, die an der Entwicklung der STIL Software arbeiten, gefragt, welche Funktionen sie sich vorstellen könnten. Es wird abgewogen, ob diese Funktionen umsetzbar sind und dementsprechend als Anforderung definiert.

Im Anschluss kann mit der Entwicklung eines Konzeptes für das Gesamtsystem fortgesetzt werden. Es werden Informationen gesammelt, welche Möglichkeiten es zur Umsetzung gibt und ob sie den Anforderungen und Use-Cases standhalten. Zusätzlich werden neue Module eingeführt und deren Aufgaben und Funktionen bestimmt und bestehende Module eventuell erweitert.

Als nächster Schritt werden einzelne Teile des Models detailierter beschrieben. Hierzu werden verschiedene UML-Diagramme verwendet, die den Aufbau, die Abhängigkeiten und die Funktionen der Module beschreiben.
\workTodo{Die Modelentwicklung des neuen BS erklären mithilfe Schaubilder, Module, PAP, ect.}

\section{Anforderungen an das neue Betriebssystem}
\label{sec:entw-anforderunge}

\section{Konzeptentwurf}
\section{Interprozess Kommunikation}
\section{Module}
\subsection{Scheduler}
\subsection{Tasker}
\subsection{Interprozesscommunication}

\newpage
\chapter{Entwicklung eines Prototyps}
\label{chap:impl}
\workTodo{Wie wurde bei der Implementierung vorgegangen, evtl. Code Snippets usw.}

\newpage
\chapter{Analyse}
\label{chap:tests}
\workTodo{Erste Tests mit paralleler ausführung von mehreren Testfunktionen, Fehlererläuterungen, Lösungen}




